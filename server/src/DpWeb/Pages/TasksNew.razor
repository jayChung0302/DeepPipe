@page "/tasks/new";

@implements IDisposable;

@using Blazor.FileReader;
@using DpDb;
@using DpWeb.Services;
@using Microsoft.Extensions.Logging;
@using System.Buffers;
@using System.Diagnostics;
@using System.IO;
@using System.Security.Cryptography;
@using System.Text;
@using System.Threading;
@using System.Threading.Tasks;

@inject IFileReaderService fileReaderService
@inject ProcessService processService
@inject NavigationManager navManager
@inject DpDbContext context
@inject ILogger<TasksNew> logger

    <style>
    .@dropTargetClass {
        display: block;
        padding: 20px;
        margin-bottom: 10px;
        border: 1px dashed black;
        border-radius: 5px;
        position: relative;
    }
    .@dropTargetDragClass {
        border-color: orangered;
        font-weight: bold;
    }
    input.clickable {
        position: absolute;
        width: 100%;
        height: 100%;
        opacity: 0;
        margin-top: -20px;
        margin-left: -20px;
        cursor: pointer;
    }
    </style>

@if (!isReceiving)
{
<div class="@dropTargetClass @(isHover ? dropTargetDragClass : string.Empty)">
    <input type="file"
           class="clickable"
           @ref="fileTarget"
           @ondragenter="OnDragEnter"
           @ondragleave="OnDragLeave"
           @onchange="RefreshFileAsync"/>
    @(fileInfo?.Name ?? "Drop file here.")
</div>

<button class="btn btn-primary btn-lg btn-block" @onclick="UploadFileAsync">Upload</button>
}
else
{
<div class="progress" style="height: 30px">
    <div class="progress-bar"
         role="progressbar"
         style="width: @(progress)%"
         aria-valuemin="0"
         aria-valuemax="100"
         aria-valuenow="@progress"> @(progress)%</div>
</div>
}

@code {
    private const string dropTargetDragClass = "droptarget-drag";
    private const string dropTargetClass = "droptarget";
    private bool isHover = false;
    private CancellationTokenSource tokenSource = new CancellationTokenSource();
    private ElementReference fileTarget;
    private IFileReaderRef fileReaderRef;
    private IFileReference fileReference = null;
    private IFileInfo fileInfo = null;
    private bool isReceiving = false;
    private int progress = 0;

    protected override void OnAfterRender(bool firstRender)
    {
        if (firstRender)
        {
            fileReaderRef = fileReaderService.CreateReference(fileTarget);
        }
    }

    private void OnDragEnter(EventArgs e)
    {
        this.isHover = true;
    }

    private void OnDragLeave(EventArgs e)
    {
        this.isHover = false;
    }

    private async Task RefreshFileAsync()
    {
        var files = await fileReaderRef.EnumerateFilesAsync().ConfigureAwait(true);
        if (files.FirstOrDefault() is IFileReference newFileReference &&
            await newFileReference.ReadFileInfoAsync().ConfigureAwait(true) is IFileInfo newFileInfo &&
            newFileInfo.Type.StartsWith("video/"))
        {
            this.fileReference = newFileReference;
            this.fileInfo = newFileInfo;
        }
        else
        {
            this.fileReference = null;
            this.fileInfo = null;
        }
        this.isHover = false;
        StateHasChanged();
    }

    private async Task UploadFileAsync()
    {
        await RefreshFileAsync().ConfigureAwait(true);
        if (fileReference == null)
        {
            return;
        }

        try
        {
            isReceiving = true;
            var fileInfo = await fileReference.ReadFileInfoAsync().ConfigureAwait(true);
            logger.LogInformation("Receiving {@}", new { fileInfo.Name });
            string tempFileName = Path.GetTempFileName();
            var token = tokenSource.Token;
            await using (var remoteFileStream = await fileReference.OpenReadAsync().ConfigureAwait(true))
            await using (var localFileStream = new FileStream(tempFileName, FileMode.Open))
            using (var owner = MemoryPool<byte>.Shared.Rent(4 * 1024 * 1024))
            using (var md5 = new MD5CryptoServiceProvider())
            {
                var buffer = owner.Memory;
                int bytesRead = 0;
                do
                {
                    bytesRead = await remoteFileStream.ReadAsync(buffer, token).ConfigureAwait(true);
                    await localFileStream.WriteAsync(buffer.Slice(0, bytesRead), token).ConfigureAwait(true);
                    progress = (int)(localFileStream.Length * 100 / fileInfo.Size);
                    StateHasChanged();
                } while (bytesRead > 0);

                localFileStream.Seek(0, SeekOrigin.Begin);
                var sb = new StringBuilder();
                foreach (byte v in md5.ComputeHash(localFileStream))
                {
                    sb.AppendFormat("{0:x2}", v);
                }
                var pipeTask = new PipeTask
                {
                    PipeTaskId = Guid.NewGuid(),
                    Registered = DateTime.UtcNow,
                    VideoMD5 = sb.ToString(),
                };
                processService.Invoke(pipeTask.PipeTaskId, tempFileName);
                await context.TbPipeTask.AddAsync(pipeTask, token).ConfigureAwait(true);
                await context.SaveChangesAsync(token).ConfigureAwait(true);
                navManager.NavigateTo($"/tasks/{pipeTask.PipeTaskId}");
            }
        }
        finally
        {
            isReceiving = false;
        }
    }

    public void Dispose()
    {
        tokenSource?.Cancel();
        tokenSource?.Dispose();
        tokenSource = null;
    }
}
